---
title: PanResponder
category: Facebook API
---
<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## PanResponder

`PanResponder` reconciles several touches into a single gesture. It makes
single-touch gestures resilient to extra touches, and can be used to
recognize simple multi-touch gestures.

By default, `PanResponder` holds an `InteractionManager` handle to block
long-running JS events from interrupting active gestures.

It provides a predictable wrapper of the responder handlers provided by the
[gesture responder system](docs/gesture-responder-system.html).
For each handler, it provides a new `gestureState` object alongside the
native event object:

    onPanResponderMove: (event, gestureState) => {}

A native event is a synthetic touch event with the following form:

-   `nativeEvent`
    -   `changedTouches` - Array of all touch events that have changed since the last event
    -   `identifier` - The ID of the touch
    -   `locationX` - The X position of the touch, relative to the element
    -   `locationY` - The Y position of the touch, relative to the element
    -   `pageX` - The X position of the touch, relative to the root element
    -   `pageY` - The Y position of the touch, relative to the root element
    -   `target` - The node id of the element receiving the touch event
    -   `timestamp` - A time identifier for the touch, useful for velocity calculation
    -   `touches` - Array of all current touches on the screen

A `gestureState` object has the following:

-   `stateID` - ID of the gestureState- persisted as long as there at least
     one touch on screen
-   `moveX` - the latest screen coordinates of the recently-moved touch
-   `moveY` - the latest screen coordinates of the recently-moved touch
-   `x0` - the screen coordinates of the responder grant
-   `y0` - the screen coordinates of the responder grant
-   `dx` - accumulated distance of the gesture since the touch started
-   `dy` - accumulated distance of the gesture since the touch started
-   `vx` - current velocity of the gesture
-   `vy` - current velocity of the gesture
-   `numberActiveTouches` - Number of touches currently on screen

### Basic Usage

      componentWillMount: function() {
        this._panResponder = PanResponder.create({
          // Ask to be the responder:
          onStartShouldSetPanResponder: (evt, gestureState) => true,
          onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
          onMoveShouldSetPanResponder: (evt, gestureState) => true,
          onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,

          onPanResponderGrant: (evt, gestureState) => {
            // The gesture has started. Show visual feedback so the user knows
            // what is happening!

            // gestureState.d{x,y} will be set to zero now
          },
          onPanResponderMove: (evt, gestureState) => {
            // The most recent move distance is gestureState.move{X,Y}

            // The accumulated gesture distance since becoming responder is
            // gestureState.d{x,y}
          },
          onPanResponderTerminationRequest: (evt, gestureState) => true,
          onPanResponderRelease: (evt, gestureState) => {
            // The user has released all touches while this view is the
            // responder. This typically means a gesture has succeeded
          },
          onPanResponderTerminate: (evt, gestureState) => {
            // Another component has become the responder, so this gesture
            // should be cancelled
          },
          onShouldBlockNativeResponder: (evt, gestureState) => {
            // Returns whether this component should block native components from becoming the JS
            // responder. Returns true by default. Is currently only supported on android.
            return true;
          },
        });
      },

      render: function() {
        return (
          <View {...this._panResponder.panHandlers} />
        );
      },

### Working Example

To see it in action, try the
[PanResponder example in UIExplorer](https://github.com/facebook/react-native/blob/master/Examples/UIExplorer/js/PanResponderExample.js)

### \_initializeGestureState

A graphical explanation of the touch data flow:

\+----------------------------+             +--------------------------------+
| ResponderTouchHistoryStore |             |TouchHistoryMath                |
\+----------------------------+             +----------+---------------------+
|Global store of touchHistory|             |Allocation-less math util       |
|including activeness, start |             |on touch history (centroids     |
|position, prev/cur position.|             |and multitouch movement etc)    |
\|                            \|             \|                                \|
\+----^-----------------------+             +----^---------------------------+
     \|                                          \|
     | (records relevant history                |
     |  of touches relevant for                 |
     |  implementing higher level               |
     |  gestures)                               |
     \|                                          \|
\+----+-----------------------+             +----|---------------------------+
| ResponderEventPlugin       |             |    |   Your App/Component      |
\+----------------------------+             +----|---------------------------+
|Negotiates which view gets  | Low level   |    |             High level    |
|onResponderMove events.     | events w/   |  +-+-------+     events w/     |
|Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
|ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
\+----------------------------+ attached to |  |         |     distance and  |
                                each event |  +---------+     velocity.     |
                                           \|                                \|
                                           \|                                \|
                                           \+--------------------------------+

Gesture that calculates cumulative movement over time in a way that just
"does the right thing" for multiple touches. The "right thing" is very
nuanced. When moving two touches in opposite directions, the cumulative
distance is zero in each dimension. When two touches move in parallel five
pixels in the same direction, the cumulative distance is five, not ten. If
two touches start, one moves five in a direction, then stops and the other
touch moves fives in the same direction, the cumulative distance is ten.

This logic requires a kind of processing of time "clusters" of touch events
so that two touch moves that essentially occur in parallel but move every
other frame respectively, are considered part of the same movement.

Explanation of some of the non-obvious fields:

-   moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
    invalid. If a move event has been observed, `(moveX, moveY)` is the
    centroid of the most recently moved "cluster" of active touches.
    (Currently all move have the same timeStamp, but later we should add some
    threshold for what is considered to be "moving"). If a palm is
    accidentally counted as a touch, but a finger is moving greatly, the palm
    will move slightly, but we only want to count the single moving touch.
-   x0/y0: Centroid location (non-cumulative) at the time of becoming
    responder.
-   dx/dy: Cumulative touch distance - not the same thing as sum of each touch
    distance. Accounts for touch moves that are clustered together in time,
    moving the same direction. Only valid when currently responder (otherwise,
    it only represents the drag distance below the threshold).
-   vx/vy: Velocity.

**Parameters**

-   `gestureState`  

### \_updateGestureStateOnMove

This is nuanced and is necessary. It is incorrect to continuously take all
active _and_ recently moved touches, find the centroid, and track how that
result changes over time. Instead, we must take all recently moved
touches, and calculate how the centroid has changed just for those
recently moved touches, and append that change to an accumulator. This is
to (at least) handle the case where the user is moving three fingers, and
then one of the fingers stops but the other two continue.

This is very different than taking all of the recently moved touches and
storing their centroid as `dx/dy`. For correctness, we must _accumulate
changes_ in the centroid of recently moved touches.

There is also some nuance with how we handle multiple moved touches in a
single event. With the way `ReactNativeEventEmitter` dispatches touches as
individual events, multiple touches generate two 'move' events, each of
them triggering `onResponderMove`. But with the way `PanResponder` works,
all of the gesture inference is performed on the first dispatch, since it
looks at all of the touches (even the ones for which there hasn't been a
native dispatch yet). Therefore, `PanResponder` does not call
`onResponderMove` passed the first dispatch. This diverges from the
typical responder callback pattern (without using `PanResponder`), but
avoids more dispatches than necessary.

**Parameters**

-   `gestureState`  
-   `touchHistory`  

### create

**Parameters**

-   `config` **[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Enhanced versions of all of the responder callbacks
    that provide not only the typical `ResponderSyntheticEvent`, but also the
    `PanResponder` gesture state.  Simply replace the word `Responder` with
    `PanResponder` in each of the typical `onResponder*` callbacks. For
    example, the `config` object would look like:-   `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
    -   `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
    -   `onStartShouldSetPanResponder: (e, gestureState) => {...}`
    -   `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
    -   `onPanResponderReject: (e, gestureState) => {...}`
    -   `onPanResponderGrant: (e, gestureState) => {...}`
    -   `onPanResponderStart: (e, gestureState) => {...}`
    -   `onPanResponderEnd: (e, gestureState) => {...}`
    -   `onPanResponderRelease: (e, gestureState) => {...}`
    -   `onPanResponderMove: (e, gestureState) => {...}`
    -   `onPanResponderTerminate: (e, gestureState) => {...}`
    -   `onPanResponderTerminationRequest: (e, gestureState) => {...}`
    -   `onShouldBlockNativeResponder: (e, gestureState) => {...}`

        In general, for events that have capture equivalents, we update the
        gestureState once in the capture phase and can use it in the bubble phase
        as well.

        Be careful with onStartShould\* callbacks. They only reflect updated
        `gestureState` for start/end events that bubble/capture to the Node.
        Once the node is the responder, you can rely on every start/end event
        being processed by the gesture and `gestureState` being updated
        accordingly. (numberActiveTouches) may not be totally accurate unless you
        are the responder.

## InteractionManager

InteractionManager allows long-running work to be scheduled after any
interactions/animations have completed. In particular, this allows JavaScript
animations to run smoothly.

Applications can schedule tasks to run after interactions with the following:

    InteractionManager.runAfterInteractions(() => {
      // ...long-running synchronous task...
    });

Compare this to other scheduling alternatives:

-   requestAnimationFrame(): for code that animates a view over time.
-   setImmediate/setTimeout(): run code later, note this may delay animations.
-   runAfterInteractions(): run code later, without delaying active animations.

The touch handling system considers one or more active touches to be an
'interaction' and will delay `runAfterInteractions()` callbacks until all
touches have ended or been cancelled.

InteractionManager also allows applications to register animations by
creating an interaction 'handle' on animation start, and clearing it upon
completion:

    var handle = InteractionManager.createInteractionHandle();
    // run animation... (`runAfterInteractions` tasks are queued)
    // later, on animation completion:
    InteractionManager.clearInteractionHandle(handle);
    // queued tasks run if all handles were cleared

`runAfterInteractions` takes either a plain callback function, or a
`PromiseTask` object with a `gen` method that returns a `Promise`.  If a
`PromiseTask` is supplied, then it is fully resolved (including asynchronous
dependencies that also schedule more tasks via `runAfterInteractions`) before
starting on the next task that might have been queued up synchronously
earlier.

By default, queued tasks are executed together in a loop in one
`setImmediate` batch. If `setDeadline` is called with a positive number, then
tasks will only be executed until the deadline (in terms of js event loop run
time) approaches, at which point execution will yield via setTimeout,
allowing events such as touches to start interactions and block queued tasks
from executing, making apps more responsive.

### runAfterInteractions

Schedule a function to run after all interactions have completed. Returns a cancellable
"promise".

**Parameters**

-   `task` **Task?** 

Returns **{then: [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), done: [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), cancel: [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)}** 

### createInteractionHandle

Notify manager that an interaction has started.

Returns **Handle** 

### clearInteractionHandle

Notify manager that an interaction has completed.

**Parameters**

-   `handle` **Handle** 

### setDeadline

A positive number will use setTimeout to schedule any tasks after the
eventLoopRunningTime hits the deadline value, otherwise all tasks will be
executed in one setImmediate batch (default).

**Parameters**

-   `deadline` **[number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** 

## \_scheduleUpdate

Schedule an asynchronous update to the interaction state.

## \_processUpdate

Notify listeners, process queue, etc
